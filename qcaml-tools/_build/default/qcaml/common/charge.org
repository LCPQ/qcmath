#+begin_src elisp tangle: no :results none :exports none
(setq pwd (file-name-directory buffer-file-name))
(setq name (file-name-nondirectory (substring buffer-file-name 0 -4)))
(setq lib (concat pwd "lib/"))
(setq testdir (concat pwd "test/"))
(setq mli (concat lib name ".mli"))
(setq ml  (concat lib name ".ml"))
(setq test-ml  (concat testdir name ".ml"))
(org-babel-tangle)
#+end_src 


* Charge
  :PROPERTIES:
  :header-args: :noweb yes :comments both
  :END:

** Type

   <<<~Charge.t~>>>
   #+begin_src ocaml :tangle (eval mli)
type t
   #+end_src

   This type should be used for all charges in the program (electrons, nuclei,...).

   #+begin_src ocaml :tangle (eval ml) :exports none
type t = float
   #+end_src

** Conversions

   #+begin_src ocaml :tangle (eval mli)
val of_float : float -> t
val to_float : t -> float

val of_int   : int -> t
val to_int   : t -> int

val of_string: string -> t
val to_string: t -> string 
   #+end_src

   #+begin_src ocaml :tangle (eval ml) :exports none
external of_float : float -> t = "%identity"
external to_float : t -> float = "%identity"

let of_int = float_of_int
let to_int = int_of_float

let of_string = float_of_string 

let to_string x = 
  if x >  0. then
    Printf.sprintf "+%f" x
  else if x < 0. then
    Printf.sprintf "%f" x
  else 
    "0.0"
   #+end_src

** Simple operations

   #+begin_src ocaml :tangle (eval mli)
val ( + ) : t -> t -> t
val ( - ) : t -> t -> t
val ( * ) : t -> float -> t
val ( / ) : t -> float -> t 
val is_null : t -> bool
   #+end_src

   #+begin_src ocaml :tangle (eval ml) :exports none
let gen_op op =
  fun a b ->
  op (to_float a) (to_float b)
  |> of_float

let ( + ) = gen_op ( +. )
let ( - ) = gen_op ( -. )
let ( * ) = gen_op ( *. )
let ( / ) = gen_op ( /. )

let is_null t = t == 0.
   #+end_src

** Printers

   #+begin_src ocaml :tangle (eval mli)
val pp : Format.formatter -> t -> unit
   #+end_src

   #+begin_src ocaml :tangle (eval ml) :exports none
let pp ppf x = 
  Format.fprintf ppf "@[%s@]" (to_string x)
   #+end_src

